> ## 数据库

## ER图?
Entity-Relation,  属性、依赖关系图

## SQL与NoSQL区别?
- SQL基于表, NoSQL不用提前建表
- SQL数据结构为表, NoSQL可以任意格式
- SQL数据分层不容易, NoSQL数据分层容易
- SQL支持丰富的多表查询
- SQL事物支持度较高, NoSQL事物支持度不高
- SQL速度没有NoSQL速度快

## 数据库分表? 分片规则? 分表带来的事物问题、join查询、全局主键重复问题如何解决?
数据库分表分为垂直切分和水平切分

垂直切分: 
- 垂直分表: 大表拆小表, 可以增加数据读取行数
- 垂直分库: 将关联度相同的表放在一起

水平切分: 
- 库内分表: 库内水平切分表, 不能缓解数据库IO压力, 只能减小单个表的大小; 用处不大
- 分库分表: 有三种拆分方法, 根据范围; 根据主键哈希; 映射关系

分表带来的事物问题: 最终一致性去解决

join查询问题: 
- 全局表: 某个表全局都用
- 数据冗余, 缓存某些反范式的字段
- 分表查询后进行组合
- 根据关系进行切分

## 事物的两个特性? 
事物传播以及隔离

## 什么是存储过程? 与函数有什么区别和联系?
存储过程与函数类似, 但是会编译后进行存储, 功能大

区别: 
- 存储过因为编译, 所以运行速度大于函数
- 存储过程作为独立部分执行, 函数作为查询语句的一部分嵌套在select中执行
- 函数不能操作实体表, 只能操作内建表
- 存储过程一般为逻辑较复杂的操作, 函数一般功能较单一如max, min

## 什么是游标?
游标可以遍历多行返回结果并处理其中一个结果

使用方法: 
- 定义游标 `declare 游标名 cursor for select 语句`
- 打开游标 `open 游标名`
- 获取结果 `fetch 游标名 into 变量名`
- 关闭游标 `close 游标名`

## 什么是触发器?
一个特殊类型的存储过程, 由事件来触发, 自动完成SQL语句; 隐式调用, 保证数据有效性和完整性

## 什么是视图? 如何进行操作?
视图为虚表, 由基本表中选取的数据组成的逻辑窗口, 不存放真实数据.
- 简化查询数据
- 提高数据的安全性

## 什么是ACID? 具体?
- Atomic,原子性, 操作要么成功, 要么失败
- Consistent, 一致性, 事物中一次和多次操作结果都相同
- Isolation, 隔离性, 事物之间不相互影响
- Durability, 已提交的事物对数据库所做的更新必须永久保存

## 说一下一范式, 二范式, 三范式? 举例说明
- 一范式: 数据原子性, 不可分割
- 二范式: 不能存在部分依赖
- 三范式: 不能存在传递依赖

## InnoDB乐观锁如何实现?
通过MVCC + undo log 完成 RC
通过MVCC + Next-Key lock 完成 RP

## InnoDB有多少种日志?
- 慢日志
- 查询日志
- 错误日志
- 事务日志
- 中继日志
- 二进制日志

## MySQL中redo log与undo log区别?
- redo log:
大部分为物理日志, 其记录时间点为缓存页面修改完成, 但数据还没有刷入磁盘之前(事务提交), 即日志一定要比数据先到磁盘, 以保证事物持久性
- undo log:
基本为逻辑日志, 记录时间点为修改缓存页面之前, 保证事物发生之前的一个版本, 可以用于回滚

## MySQL约束类型?
主键约束, 外键约束, 唯一约束, 非空约束

## MySQL有哪些语言? 
Define
Managment
Query
Control

## MySQL有哪些数据类型? ip用什么类型存储? 电话号码用什么类型存储?
- 整数类型: 
包括tinyint(8), smallint(16), mediumint(24), int(32), bigint(64); int(11)中只是规定交互工具显示字符的个数, 对存储和计算是没有意义的
- 字符串类型: char和varchar(20); 
varchar性能高于char,  但是在进行修改时会进行扩展可能导致需要额外操作; 
carchar会存储字符串末尾的空格, char则不会保留字符串末尾的空格
- 日期和时间
datetime:精确到秒, 8字节, 与时区无关
timestamp: 4字节, 和unit时间戳相同, 会默认插入当前时间

## MySQL连接有哪些方式? 内连接与外连接有什么区别? 默认使用什么连接?
连接方式: 外连接, 内连接

外连接: 分为left join, right join

内连接: inner join(只有join关键字时的默认连接方式), a inner join b 与 from a,b效果一致(说法不同)

## MySQL中exist和in的区别?
- exist 
先查询外表再查询子表, 将外部查询结果在子查询结果中进行匹配, 内标可以使用索引
- in
先查询子表再查询外标, 将内表中的结果与外表中的结果进行关联

## union和union all区别?
union是将字段相同的记录合在一起,  默认去除重复字段; all加上后显示所有字段

## group by, having, where区别?
group by 是分组 在where之后

having是分组过滤, 在group by 之后

`select distinct id, count(*) from table_name where id > 20 group by id having count(id) > 3;`

## count(\*), count(column), count(1)的区别?
`count(*)` 与 count(1)效果类似, 一般使用 `count(*)`,  不会过滤空字段
count(column)会过滤空字段

## drop, truncate, delete区别?
- drop: 删除表结构表数据, 不可恢复
- truncate:删除表数据, 不可恢复, 删除后的表数据恢复id顺序
- delete: 删除表数据, 可以恢复, 删除后id不重新按顺序

## MySQL有哪些搜索引擎? MySQL索引有哪些? 什么是倒排索引?
- B+ Tree
- 哈希索引, 自适应哈希索引(B+ Tree 查询频繁字段自动生成哈希索引)
- 基于图
- 全文检索(倒排序):通过字段查询文章, 而不是通过文章查询字段

## MySQL如何删除外键? 
alter table table_name drop foreign key uid;

## MySQL数据库索引原理? 
B+ Tree索引, 将相对无序的数据变为相对有序的数据,  方便检索

## MySQL数据库优化? 
- 搜索优化, 索引优化
- 从数据库结构: 水平切分和垂直切分
- 从缓存角度
- 分布式

## 聚集索引与非聚集索引区别?
- 聚集索引: 叶子中的数据为数据本身
- 非聚集索引: 叶子中的数据为数据指针

## MySQL索引优化? 
- 前缀索引优化
- 索引不参与计算
- 主键, 外键创建索引
- 尽可能选择区分度高的字段为索引
- 避免全文索引
- 使用模糊查询时, %不放在最前面
- 使用where等条件查询时, 要使索引生效需要全部条件都为索引字段

## 为什么要使用索引? 索引那么多有点为什么不对表中的每一列都创建索引?
索引优点: 
- 使得每一行数据唯一
- 多表查询时提升查询速度
- 索引提升数据库查询速度

不对每一列都建立索引的原因在于: 
- 索引的创建需要空间与时间
- 索引的维护需要时间
- 过多的索引会占据内存空间

## 什么是覆盖索引?
查询语句中的结果全部为索引, 查询出来后不需要再去通过索引查询非索引字段, 提升查询速度

## 索引是如何提高查询速度的?
将相对无需的数据变为相对有序的数

## MySQL在哪些情况下索引会失效?
- 数据库认为不使用索引查询的速度高于使用索引查询的速度
- 在使用条件查询中存在非索引条件
- 模糊查询使用%前缀
- 前缀查询时, 第一个字段不是索引

## MySQL索引使用条件? 性别适合使用索引嘛? 
区分度高的字段使用索引, 性别区分度不高, 不适合索引

## MySQL如何优化数据访问?
- 查询感兴趣的字段
- 按行数查询
- 使用索引

## 什么是最左匹配原则? 什么是联合索引?
最左匹配原则基于联合索引, 在创建联合索引如(a,b,c)时, 数据库会自动创建三个索引分别为: (a), (a, b), (a, b, c).当使用的(b, c)或(d, b, c)时, 索引不生效.

## MySQL封锁粒度? 封锁类型? 封锁协议? 
封锁粒度: 行锁和表锁

类型: 独占锁排他锁, 意向锁

封锁协议: 两次阶段, 加锁与解锁两阶段进行

## 什么是当前读与快照读?
- 当前读: 使用悲观锁进行读取数据
- 快照度: 不使用锁, 使用MVCC+日志的方式进行读取

## MySQL有哪些锁? InnoDb行锁有几种? 什么是死锁? 数据库死锁如何解决?
MySQL锁: 
- record lock, 记录本身所在索引
- gap lock, 间隙锁, 记录本身索引之间的记录, 不包括记录本身索引
- next-key lock, 前两者的集合

## InnoDB的行锁加什么完成?
默认的和update

## MySQL事物隔离级别? 各自会带来什么问题? 
以下事物为InnoDB事务
- read uncommit
读取未提交事物, 会造成脏读
- read commit
读取已提交事物, 会造成不可重复读, 如读取某一行数据前后两次读取结果不同
- repeatable read
保证多个实例在并发读取数据时会看到相同的数据; 会造成幻读(重新读取某个范围时, 数据行不一致)
- serializable
强制事物排序使之不能相互冲突, 可以解决幻读

## MySQL如何解决RC, RP带来的问题? 什么是MVCC?
使用MVCC解决RC,  使用MVCC+Next-key lock解决RP

MVCC(Multi-Version Concurrency Control, 多版本并发控制), 通过在记录行添加两列字段, 创建版本号与删除版本号进行控制
- 读取: 读取创建版本号早于当前版本号并且删除版本号大于当前版本号的字段
- 删除: 删除时将原数据行的删除版本号改为当前事物版本号
- 更新: 复制原数据行, 将新行数据创建版本改为当前事物版本, 原数据行的删除数据版本号改为当前事物版本号

## MySQL如何解决幻读? 
MVCC+next-key lock

## MySQL主从复制过程? 读写分离好处? 
过程: 
- binlog: 负责将主服务器数据更改写入二进制日志中
- IO线程: 将数据从主服务器的二进制日志中写入从服务器的中继日志中
- SQL线程: 负责读取从服务器的中继日志, 并进行更改

## InnoDB与MyISAM的区别?
- InnoDB支持事物, MyISAM不支持事物
- InnoDB支持行锁, MyISAM不支持行锁
- InnoDB不记录行数,MyISAM记录行数
- 删除InnoDB数据时, 一行行删除; 删除MyISAM时重构表结构
- InnoDB支持外键, MyISAM不支持外键

## 如果数据库日志满了, 会出现什么情况?
只能用于查询操作, 修改更新删除操作需要写入日志

## 如何查看慢查询?
查看慢日志, 前提是开启了慢日志, 并设置慢日志的时间

## B+ Tree 与B Tree区别?
B+ Tree只有根节点存储数据, 而B Tree每个节点都存储数据

## B+ Tree操作过程?
使用二分查找根节点中的指针, 然后指向下一个节点, 递归查询到叶子节点, 叶子节点查询出来的数据如果是聚集索引则直接返回结果, 若为非聚集索引则通过指针查询数据

## B+ Tree 与红黑树比较?
相同节点情况下因为B+ Tree的出度大, 整个数的高度低, 复杂度要低于红黑树

## JDBC处理事务采用什么方法?
采用与数据库一致的事物并加上一个不采取事物操作

## JDBC中getString()和getObject()区别?
getString()是一次查询结果, getObject()是一部分一部分地取出结果

## 数据库如何查询大数据
- 可以分表然后再查询
- 分段查询
- 查询感兴趣字段
- 使用索引查询

---
## Redis是数据库吗? 
Redis不用于数据库, 虽然有持久化机制, 但一般作为缓存使用

## 为什么Redis是单线程还这么快? 
- 多路复用
- 存储在内存中

## Redis数据持久化如何实现?
- RDB: 父线程fork一个子线程, 子线程复制父进程的数据并存储
- AOF: append of file, 每操作一次将操作指令写入日志文件中, 但会造成日志文件过大

## AOF文件过大如何解决?
对AOF进行重写

## Redis如何保证原子性?
通过单线程保证原子性

## Redis主从复制模式下, 主挂了怎么办? 
通过哨兵模式, 主服务器挂了之后从服务器会通过选举选出一个新的主服务器

## Redis缓存更新策略?
- 定时过期: 对字段设置失效时间
- 惰性过期: 查询时判断字段是否过期

## Redis底层数据结构(有哪些数据类型)? 跳跃表如何实现? 压缩列表是什么?
- string类型
- list类型
- 字典
- 跳跃表: 通过链表实现类似于二分查找的功能
- 整数集合
- 压缩列表: 将字段按照一定地规则编码在一块连续的内存区域, 目的是解决内存

## Redis使用场景?
- 缓存
- 计数器
- 查询表
- 集合排序、过滤
- 订阅/发布

## 与Memcached比较?
- M本身不支持分布式需要通过一致性哈希算法
- M本身只支持字符串, R支持多种类型
- M本身不支持持久化, R支持持久化
- M只存储在内存中, R可以通过日志存储在磁盘中

## Redis数据淘汰策略?
- volatile-lru: 从已经设置过期的数据集中选出最近最少使用数据淘汰
- volatile-ttl(time to live): 从已经设置过期的数据集中选出将要过期的数据
- volatile-random: 从已经设置过期的数据集中随机选出进行淘汰
- allkeys-lru: 从所有数据集中选出最近最少使用的数据淘汰
- allkeys-random: 从所有数据集中随机选出进行淘汰
- noevication: 禁止淘汰

## Redis如何实现事务?
使用MUTI进入事物, 使用EXIT完成事物.不支持回滚操作

## Redis复制如何实现? 什么是主从链?
复制操作: 
- 主服务器创建快照文件发给从服务器并在发送期间用缓存区记录执行的写命令, 快照发送完之后将缓存中的指令发送给从服务器
- 从服务器读取快照中的指令并接受主服务器发送来得写指令
- 主服务器每写一次命令, 就向从服务器发送相同的写指令

## Redis切片?
- 客户端分片: 哈希一致
- 代理分片: 将客户端的请求发送到代理服务器上
- 服务器分片: Redis Cluster

## 常见的缓存策略?
- LRU
- LFU

## 如何防止缓存雪崩?
雪崩现象主要是指缓存大面积失效导致大量请求需要数据库处理, 从而导致系统性能下降.

解决办法: 
- 设置不同的失效时间
- 设置二级缓存
- 真正大面积失效后通过对查询数据库请求进行并发限制

## 如何防止穿透?
穿透是指客户端查询大量缓存中不存在的数据, 可能是数据库攻击

解决办法: 
- 布隆过滤, 将不可能存在的请求字段进行过滤
- 将查询为空的请求也进行缓存, 缓存时间设置短一些

## 什么是缓存预热?
系统上线时将数据库中的数据放入缓存中

## 什么是缓存无底洞现象?
缓存服务器节点增多, 性能不增反降.

原因: 各节点之间通讯费时

解决办法: 优化各节点传输的指令, 降低服务间的通信

## 如何保证缓存与数据库的双写一致性?
读取数据时, 若缓存中不存在则向数据库中查询, 然后更新缓存

修改时, 先删除缓存, 然后再更新数据库.

但上述修改方案会出现删除缓存, 数据库更新还未来得及完成时, 出现其它请求, 导致缓存中的数据是旧数据.
解决办法: 
- 更新时删除缓存, 更新完数据库之后再删除缓存, 但会在一段时间造成脏读现象的出现
- 更新时将缓存设置为指定值, 其他请求查询时若发现缓存字段为指定值则进入循环等待, 等待数据库更新完成, 若未在指定期间更新完成则查询数据库.

## MySQL数据备份与恢复
备份:  `mysqldump -u root -p dbname > dbname.sql`
恢复: `source dbname.sql`