// 2019-4-10
// 懒汉
// 这种写法能够在多线程中很好的工作，而且看起来它也具备很好的lazy loading，但是，遗憾的是，效率很低，99%情况下不需要同步。
public class Singleton {
	private static Singleton instance;
	private Singleton(){}
	public static synchronized Singleton getInstance() {
		if (instance == null) {
			instance = new Singleton();
		}
		return instance;
	}
}

// 饿汉
public class Singleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
    	return instance;  
    }  
}

// 内部静态
public class Singleton {  
    private static class SingletonHolder {  
    	private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
    	return SingletonHolder.INSTANCE;  
    }  
} 


// 双重校验锁
public class Singleton {
    private volatile static Singleton singleton;	// 防止指令重排序
    private Singleton (){}
    public static Singleton getSingleton() {
		if (singleton == null) {
		    synchronized (Singleton.class) {	// 在使用线程同步时, 处理特殊情况外基本应该使用class
				if (singleton == null) {
				    singleton = new Singleton();
				}
		    }
		}
		return singleton;
    }
}